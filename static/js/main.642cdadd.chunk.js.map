{"version":3,"sources":["assets/styles/theme.ts","components/routes/AuthRoute.tsx","components/routes/PrivateRoute.tsx","components/ui/progressIndicator/index.tsx","App.tsx","serviceWorker.ts","index.tsx","session/auth.ts","components/layout/Snackbar/SnackbarContext.tsx","components/layout/Snackbar/useSnackbar.ts","i18n.ts"],"names":["theme","createMuiTheme","palette","primary","main","secondary","error","red","A400","background","default","AuthRoute","isAuthenticated","Component","component","rest","isValidAuth","useRef","authenticated","render","props","current","to","PrivateRoute","pathname","state","from","location","useStyles","makeStyles","createStyles","root","width","alignItems","marginTop","spacing","ProgressIndicator","type","classes","className","CircularProgress","LinearProgress","Landing","lazy","Dashboard","ForgotPassword","Login","Signup","App","ThemeProvider","CssBaseline","Snackbar","fallback","exact","path","Boolean","window","hostname","match","checkAuth","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message","userSession","isAdminType","sleep","ms","Promise","r","setTimeout","login","authParams","a","username","password","dummyLoginResponseObj","token","user","fullName","isAdmin","role","Error","createSession","logout","routeHistory","redirect","localStorage","removeItem","push","session","getSession","isUndefined","hasOwnProperty","checkIsAdmin","loginResponseData","pick","id","updateUserSession","setItem","JSON","stringify","sessionJson","getItem","isNull","parse","isAdminUser","useSession","useState","setState","syncState","event","key","useEffect","addEventListener","removeEventListener","SnackbarContext","createContext","setAlert","defaultAlertConfigs","open","anchorOrigin","vertical","horizontal","autoHideDuration","SnackAlert","elevation","variant","SnackbarCtxProvider","children","configs","setConfigs","handleClose","reason","useMemo","Provider","value","onClose","severity","useSnackbar","useContext","LANGUAGES","code","text","LANGUAGES_KEY","map","lang","backendOptions","loadPath","process","i18n","use","Backend","initReactI18next","init","lng","whitelist","fallbackLng","debug","interpolation","escapeValue","backend"],"mappings":"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","file":"static/js/main.642cdadd.chunk.js","sourcesContent":["import { createMuiTheme } from \"@material-ui/core/styles\";\nimport red from \"@material-ui/core/colors/red\";\n\nconst theme = createMuiTheme({\n    palette: {\n        primary: {\n            main: \"#556cd6\"\n        },\n        secondary: {\n            main: \"#00a2d5\"\n        },\n        error: {\n            main: red.A400\n        },\n        background: {\n            default: \"#fff\"\n        }\n    }\n});\n\nexport default theme;\n","/**\n * A wrapper for <Route />\n * Redirects to Dashboard if authenticated\n * Encapsulate login related routes that needs to be redirected to dashboard if authenticated\n * (login/signup) with this component.\n */\nimport React, { ComponentClass, FC, useRef } from \"react\";\nimport { Route, Redirect } from \"react-router\";\n\nimport { authenticated } from \"session/auth\";\n\ninterface IAuthRouteProps {\n    isAuthenticated?: boolean; // Optional prop passed to check if authenticated.\n    component: ComponentClass<any, any> | FC<any>;\n    exact?: boolean; // Optional; When true, will only match if the path matches the location.pathname exactly.\n    path: string;\n}\n\nconst AuthRoute: FC<IAuthRouteProps> = ({\n    isAuthenticated,\n    component: Component,\n    ...rest\n}) => {\n    const isValidAuth = useRef(authenticated && isAuthenticated);\n\n    return (\n        <Route\n            {...rest}\n            render={(props) =>\n                isValidAuth.current ? (\n                    <Redirect to=\"/dashboard\" />\n                ) : (\n                    <Component {...props} {...rest} />\n                )\n            }\n        />\n    );\n};\n\nexport default AuthRoute;\n","/**\n * A wrapper for <Route>\n * Redirects to Login if not authenticated\n */\nimport React, { ComponentClass, FC, useRef } from \"react\";\nimport { Route, Redirect } from \"react-router\";\n\nimport { authenticated } from \"session/auth\";\ninterface IPrivateRouteProps {\n    isAuthenticated?: boolean; // Optional prop passed to check if authenticated.\n    component: ComponentClass<any, any> | FC<any>;\n    path: string;\n}\n\nconst PrivateRoute: FC<IPrivateRouteProps> = ({\n    isAuthenticated,\n    component: Component,\n    ...rest\n}: IPrivateRouteProps) => {\n    const isValidAuth = useRef(authenticated || isAuthenticated);\n    return (\n        <Route\n            {...rest}\n            render={(props) =>\n                isValidAuth.current ? (\n                    <Component {...props} {...rest} />\n                ) : (\n                    <Redirect\n                        to={{ pathname: \"/login\", state: { from: props.location } }}\n                    />\n                )\n            }\n        />\n    );\n};\n\nexport default PrivateRoute;\n","/**\n * Custom Progress Indicator\n *\n * Usage:\n *\n * Ex:\n *\n * import ProgressIndicator from \"components/ui/progressIndicator\";\n * ....\n * <ProgressIndicator type=\"linear\" />\n * ...\n */\nimport React, { FC } from \"react\";\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\";\n\nimport CircularProgress, {\n    CircularProgressProps\n} from \"@material-ui/core/CircularProgress\";\nimport LinearProgress, { LinearProgressProps } from \"@material-ui/core/LinearProgress\";\n\ninterface BaseProgressIndicatorProps {\n    /**\n     * Type of the Progress Indicator.\n     * This can be \"circular\" or \"linear\"\n     */\n    type: \"circular\" | \"linear\";\n}\n\ninterface CircularProgressIndicatorProps\n    extends CircularProgressProps,\n        BaseProgressIndicatorProps {}\n\ninterface LinearProgressIndicatorProps\n    extends LinearProgressProps,\n        BaseProgressIndicatorProps {}\n\ntype ProgressIndicatorProps =\n    | CircularProgressIndicatorProps\n    | LinearProgressIndicatorProps;\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            width: \"100%\",\n            alignItems: \"center\",\n            \"& > * + *\": {\n                marginTop: theme.spacing(1)\n            }\n        }\n    })\n);\n\nconst ProgressIndicator: FC<ProgressIndicatorProps> = ({ type }) => {\n    const classes = useStyles();\n    return (\n        <div className={classes.root}>\n            {type === \"circular\" ? <CircularProgress /> : <LinearProgress />}\n        </div>\n    );\n};\n\nexport default ProgressIndicator;\n","import React, { FC, Suspense, lazy } from \"react\";\nimport { BrowserRouter as Router, HashRouter, Switch, Redirect } from \"react-router-dom\";\nimport { ThemeProvider } from \"@material-ui/core/styles\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\n\nimport theme from \"assets/styles/theme\";\nimport \"assets/css/App.css\";\n\nimport { authenticated } from \"session/auth\";\n\nimport AuthRoute from \"components/routes/AuthRoute\";\nimport PrivateRoute from \"components/routes/PrivateRoute\";\n\nimport ProgressIndicator from \"components/ui/progressIndicator\";\nimport { SnackbarCtxProvider } from \"components/layout/Snackbar\";\n\nconst Landing = lazy(() => import(\"views/Landing\"));\n\n/* Core Components */\nconst Dashboard = lazy(() => import(\"views/Dashboard\"));\nconst ForgotPassword = lazy(() => import(\"views/Auth/ForgotPassword\"));\nconst Login = lazy(() => import(\"views/Auth/SignIn\"));\nconst Signup = lazy(() => import(\"views/Auth/SignUp\"));\n\nconst App: FC = () => {\n    return (\n        <ThemeProvider theme={theme}>\n            {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\n            <CssBaseline />\n            <div className=\"App\">\n                <SnackbarCtxProvider>\n                    <Router>\n                        <HashRouter>\n                            <Suspense fallback={<ProgressIndicator type=\"linear\" />}>\n                                <Switch>\n                                    <AuthRoute\n                                        exact\n                                        path=\"/\"\n                                        component={Landing}\n                                        isAuthenticated={authenticated}\n                                    />\n                                    <AuthRoute\n                                        exact\n                                        path=\"/login\"\n                                        component={Login}\n                                        isAuthenticated={authenticated}\n                                    />\n                                    <AuthRoute\n                                        exact\n                                        path=\"/signup\"\n                                        component={Signup}\n                                        isAuthenticated={authenticated}\n                                    />\n                                    <AuthRoute\n                                        exact\n                                        path=\"/forgot-password\"\n                                        component={ForgotPassword}\n                                    />\n                                    <PrivateRoute\n                                        path=\"/dashboard\"\n                                        component={Dashboard}\n                                        isAuthenticated={authenticated}\n                                    />\n                                    {/* Redirect to \"URL/#/login\" on invalid paths entered as \"URL/#/INVALID\" */}\n                                    <Redirect from=\"/\" to=\"/login\" />\n                                    {/* Redirect to \"URL/#/login\" on invalid paths entered as \"URL/#/login/INVALID\" */}\n                                    <Redirect from=\"/login\" to=\"/login\" />\n                                </Switch>\n                            </Suspense>\n                        </HashRouter>\n                    </Router>\n                </SnackbarCtxProvider>\n            </div>\n        </ThemeProvider>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === \"[::1]\" ||\n        // 127.0.0.0/8 are considered localhost for IPv4.\n        window.location.hostname.match(\n            /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n        )\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                            \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then((registration) => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                    \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch((error) => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: { \"Service-Worker\": \"script\" },\n    })\n        .then((response) => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then((registration) => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\"No internet connection found. App is running in offline mode.\");\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready\n            .then((registration) => {\n                registration.unregister();\n            })\n            .catch((error) => {\n                console.error(error.message);\n            });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"assets/css/index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { checkAuth } from \"session/auth\";\n\n// import i18n (needs to be bundled)\nimport \"./i18n\";\n\n/**\n * If the page is refreshed or the app closed and reopened, that status will be lost.\n * To get around that, call checkAuth when the app is first loaded.\n * This will also check the user status i.e admin or not.\n */\ncheckAuth();\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","/**\n * Authentication/user session related common functions & constants\n */\nimport { useEffect, useState } from \"react\";\n\nimport { pick } from \"lodash\";\nimport { isNull, isUndefined } from \"util\";\nimport { History } from \"history\";\n\nconst RESPONSE_LOGIN_FAIL = \"Failed to Login\"; // Common Response for Login Failure (Remove on proper login flow)\nconst SESSION_KEY: string = \"user-session\"; // local-storage key for save session\n\nexport interface ILoginParams {\n    username: string;\n    password: string;\n}\n\ninterface IKeyValueObject {\n    [key: string]: any;\n}\n\ninterface ILoginResponseData {\n    token: string;\n    user: IKeyValueObject;\n}\n\nexport let authenticated = false; // Current authentication status of the logged in user\nexport let userSession: IKeyValueObject = {}; // User Session data\nexport let isAdminType: boolean = false; // User type of the logged in user\n\n/**\n * Custom function to mimic server response wait time\n * @param ms - Time in Milliseconds\n */\nconst sleep = (ms: number) => new Promise(r => setTimeout(r, ms));\n\n/**\n * Login Authentication function\n * @param authParams - username, password contained object.\n */\nexport const login = async (authParams: ILoginParams) => {\n    await sleep(3000);\n    const { username, password } = authParams;\n    // Dummy User Login Response Object\n    const dummyLoginResponseObj = {\n        token: \"1X-45xNm-7mklIpOZ\",\n        user: {\n            username,\n            fullName: `${username}`,\n            isAdmin: username === \"admin\",\n            role: username === \"admin\" ? \"Admin\" : \"User\"\n        }\n    };\n    switch (username) {\n        case \"user\":\n            if (password !== \"Abc@1234\") {\n                throw Error(RESPONSE_LOGIN_FAIL);\n            } else {\n                createSession(dummyLoginResponseObj);\n            }\n            return dummyLoginResponseObj.user;\n        case \"admin\":\n            if (password !== \"Abc@1234\") {\n                throw Error(RESPONSE_LOGIN_FAIL);\n            } else {\n                createSession(dummyLoginResponseObj);\n            }\n            return dummyLoginResponseObj.user;\n        default:\n            throw Error(RESPONSE_LOGIN_FAIL);\n    }\n};\n\n/**\n * Remove session object localStorage data on logout.\n * @param routeHistory - History object for routing.\n * @param redirect (Optional) - Redirecting path.\n */\nexport const logout = (routeHistory: History, redirect?: string): void => {\n    localStorage.removeItem(SESSION_KEY);\n    authenticated = false;\n    if (redirect) {\n        routeHistory.push(redirect);\n    }\n};\n\n/**\n * Checks if token exists in localstorage & updates authenticated flag.\n * If authenticated checks the user authority state, i.e admin or not.\n */\nexport const checkAuth = (): void => {\n    const session = getSession();\n    if (session && !isUndefined(session)) {\n        authenticated = session.hasOwnProperty(\"token\") && session.token ? true : false;\n        checkIsAdmin();\n    } else {\n        authenticated = false;\n    }\n};\n\n/**\n * Update global scope user session object with session data.\n * @param session - session object\n */\nconst updateUserSession = (session: IKeyValueObject): void => {\n    userSession.id = session && session.id ? session.id : \"\";\n    userSession.username = session && session.username ? session.username : \"\";\n    userSession.fullName = session && session.fullName ? session.fullName : \"\";\n    userSession.isAdmin = session && session.isAdmin ? Boolean(session.isAdmin) : false;\n    userSession.token = session && session.token ? session.token : \"\";\n    userSession.role = session && session.role ? session.role : \"\";\n};\n\n/**\n * Create a session object in localStorage\n * @param loginResponseData - Response data from authentication\n */\nconst createSession = (loginResponseData: ILoginResponseData): void => {\n    const { token, user } = pick(loginResponseData, [\"token\", \"user\"]);\n    const session = { token, ...user };\n    updateUserSession(session);\n    localStorage.setItem(SESSION_KEY, JSON.stringify(userSession));\n    authenticated = true;\n    isAdminType = Boolean(user.isAdmin);\n};\n\n/**\n * Returns the session object stored in localStorage\n */\nconst getSession = (): any => {\n    let sessionJson: any = localStorage.getItem(SESSION_KEY);\n    if (sessionJson && !isNull(sessionJson)) {\n        const session = JSON.parse(sessionJson);\n        return session;\n    }\n    return null;\n};\n\n/**\n * Checks whether the user is admin type & updates the isAdminType flag\n */\nexport const checkIsAdmin = (): void => {\n    isAdminType = isAdminUser();\n};\n\n/**\n * Returns a boolean flag indicating whether user is an admin or not.\n */\nexport const isAdminUser = (): boolean => {\n    const session = getSession();\n    let isAdmin = false;\n    if (session && !isUndefined(session)) {\n        isAdmin = session.hasOwnProperty(\"isAdmin\") ? Boolean(session.isAdmin) : false;\n    } else {\n        isAdmin = false;\n    }\n    return isAdmin;\n};\n\n/**\n * React hook to handle session from browser storage\n * @param sessionKey - Browser storage key. Default is set to the key `user-session`\n * @returns If there is a session in your browser storage then it will be returned. If there is no session, it will return null.\n *\n * Usage - This hook is useful in scenarios where you need to listen to session changes in functional components\n *\n * import { useSession } from \"session/auth\";\n *\n * ...\n * <FC>\n *  const { session } = useSession();\n * </FC>\n */\nexport const useSession = () => {\n    const [state, setState] = useState<any>(getSession);\n\n    const syncState = (event: StorageEvent) => {\n        if (event.key === SESSION_KEY) {\n            setState(getSession);\n        }\n    };\n\n    useEffect(() => {\n        window.addEventListener(\"storage\", syncState);\n        return () => {\n            window.removeEventListener(\"storage\", syncState);\n        };\n    }, []);\n\n    return { session: state };\n};\n","/**\n * Snackbar Context\n */\nimport React, {\n    createContext,\n    Dispatch,\n    SetStateAction,\n    FC,\n    useState,\n    useMemo,\n    ReactNode,\n    SyntheticEvent\n} from \"react\";\nimport Snackbar from \"@material-ui/core/Snackbar\";\nimport MuiAlert, { AlertProps } from \"@material-ui/lab/Alert\";\n\ninterface ISnackbarCtxProviderProps {\n    children: ReactNode;\n}\n\ninterface ISnackbarConfigs {\n    /**\n     * Flag to trigger snackbar open or close.\n     */\n    open: boolean;\n    /**\n     * Origin point of the snack/toast\n     */\n    anchorOrigin?: {\n        horizontal: \"left\" | \"center\" | \"right\";\n        vertical: \"top\" | \"bottom\";\n    };\n    /**\n     * Text message to be displayed in snack/toast\n     */\n    message: string;\n    /**\n     * Types of snack/toast\n     */\n    type: \"error\" | \"info\" | \"success\" | \"warning\";\n    /**\n     * Optional Time taken to auto dismiss in milliseconds.\n     * Default is set to 3000\n     */\n    autoHideDuration?: number;\n}\n\ntype ISnackbarContextProps = {\n    setAlert: (\n        configs: ISnackbarConfigs\n    ) => void | Dispatch<SetStateAction<ISnackbarConfigs>>;\n};\n\n// Default auto hide duration of the toast\nconst AUTO_HIDE_DURATION = 3000;\n\nconst initialContext: ISnackbarContextProps = {\n    setAlert: () => {}\n};\n\nexport const SnackbarContext = createContext<ISnackbarContextProps>(initialContext);\n\nconst defaultAlertConfigs: ISnackbarConfigs = {\n    open: false,\n    anchorOrigin: { vertical: \"bottom\", horizontal: \"center\" },\n    message: \"\",\n    type: \"success\",\n    autoHideDuration: AUTO_HIDE_DURATION\n};\n\nfunction SnackAlert(props: AlertProps) {\n    return <MuiAlert elevation={6} variant=\"filled\" {...props} />;\n}\n\n// Snackbar or toast context-provider\nconst SnackbarCtxProvider: FC<ISnackbarCtxProviderProps> = ({\n    children\n}: ISnackbarCtxProviderProps) => {\n    // Alert configuration object\n    const [configs, setConfigs] = useState(defaultAlertConfigs);\n\n    const handleClose = (event?: SyntheticEvent, reason?: string) => {\n        if (reason === \"clickaway\") {\n            return;\n        }\n\n        setConfigs({ ...configs, open: false });\n    };\n\n    const setAlert = useMemo(() => setConfigs, [setConfigs]);\n\n    return (\n        <SnackbarContext.Provider value={{ setAlert }}>\n            <Snackbar\n                open={configs.open}\n                autoHideDuration={\n                    configs.autoHideDuration\n                        ? configs.autoHideDuration\n                        : AUTO_HIDE_DURATION\n                }\n                onClose={handleClose}\n                anchorOrigin={\n                    configs.anchorOrigin\n                        ? configs.anchorOrigin\n                        : defaultAlertConfigs.anchorOrigin\n                }>\n                <SnackAlert onClose={handleClose} severity={configs.type}>\n                    {configs.message}\n                </SnackAlert>\n            </Snackbar>\n            {children}\n        </SnackbarContext.Provider>\n    );\n};\n\nexport default SnackbarCtxProvider;\n","/**\n * ------ useSnackbar custom react hook -------\n *\n * This hook is used to trigger snack/toast in the application.\n *\n * Methods to use\n * ------------------------------------------\n *```\n *     import useSnackbar from \"components/layout/Snackbar\";\n *\n *     ... (Inside Functional component)\n *     const { setAlert } = useSnackbar();\n *\n *     setAlert({CONFIGURATIONS});\n *     ...\n *```\n * You can find/modify configurations inside \"./SnackbarContext.tsx\"\n * */\nimport { useContext } from \"react\";\n\nimport { SnackbarContext } from \"./SnackbarContext\";\n\nexport const useSnackbar = () => useContext(SnackbarContext);\n","/**\n * i18next configuration for translations\n *\n * Translations are located at public/locales/{lang}/translation.json\n */\nimport i18n from \"i18next\";\nimport { initReactI18next } from \"react-i18next\";\n\nimport Backend from \"i18next-http-backend\";\n\nexport const LANGUAGES = [\n    {\n        code: \"en\",\n        text: \"English\"\n    },\n    {\n        code: \"si\",\n        text: \"සිංහල\"\n    }\n];\n\nexport const LANGUAGES_KEY = LANGUAGES.map(lang => {\n    return lang.code;\n});\n\nconst backendOptions = {\n    // path where resources get loaded from, or a function\n    // returning a path:\n    // function(lngs, namespaces) { return customPath; }\n    // the returned path will interpolate lng, ns if provided like giving a static path\n    loadPath: `${process.env.REACT_APP_GH_HOMEPAGE}/locales/{{lng}}/{{ns}}.json`\n};\n\ni18n\n    // load translation using http -> see /public/locales\n    .use(Backend)\n    // pass the i18n instance to react-i18next.\n    .use(initReactI18next)\n    .init({\n        lng: \"en\",\n        whitelist: LANGUAGES_KEY,\n        fallbackLng: \"en\",\n        debug: true,\n\n        interpolation: {\n            escapeValue: false // Not needed for react as it escapes by default\n        },\n        backend: backendOptions\n    });\n\nexport default i18n;\n"],"sourceRoot":""}